/**********************************************************************************************************************
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/**        \file  IntCtrl.c
 *        \brief  
 *
 *      \details  
 *
 *
 *********************************************************************************************************************/

/*****************************************************INCLUDES********************************************************/
#include "../Common/Std_Types.h"
#include "../Config/IntCtrl_Cfg.h"
#include "../Common/Mcu_Hw.h"
#include "../Mcal/Inc/IntCtrl_Types.h"
#include "Inc/IntCtrl.h"

/******************************************LOCAL MACROS CONSTANT\FUNCTION*********************************************/
#define APINT_VECTKEY           0x05FA

#define INTCTRL_INT_A           0
#define INTCTRL_INT_B           1
#define INTCTRL_INT_C           2
#define INTCTRL_INT_D           3

extern IntCtrl_Interrupt_st interrupts[NUMBER_OF_USED_INTERRUPTS];

/*
 * Syntax          : void IntCtrl_Init(void)        
 * Description     : Describe this service                                    
 *                                                                             
 * Sync\Async      : Synchronous                                               
 * Reentrancy      : Non Reentrant                                             
 * Parameters (in) : None                    
 * Parameters (out): None                                                      
 * Return value:   : None                                 
 */
void IntCtrl_Init(void)
{
    uint8 interruptNumber ;

    /*TODO: Configure Grouping/Subgrouping system in APINT register in SCB.*/
    APINT = (APINT_VECTKEY << 16) | (INTERRUPT_PRIORITY_LEVEL_SEL << 8);

    /*TODO: Assign Group/Subgroup priority in NVIC_PRIx Nvic and SCB_SYSPRIx Registers.*/
    for(uint8 i=0; i<NUMBER_OF_USED_INTERRUPTS; i++)
    {
        interruptNumber = interrupts[i].interruptNumber;
        uint8 numberOfPriReg = interruptNumber / 4;

        uint32* p_wantedPriRegAddress = ((volatile uint32*)(PRI_BASE_ADDRESS)) + numberOfPriReg;
        uint32 priReg = *p_wantedPriRegAddress;

        uint8 interruptSection = interruptNumber - (numberOfPriReg * 4);




#if INTERRUPT_PRIORITY_LEVEL_SEL == 0x4
        switch(interruptSection)
        {
            case INTCTRL_INT_A:
            priReg |= interrupts[i].groupPriority << 5;
            break;

            case INTCTRL_INT_B:
            priReg |= interrupts[i].groupPriority << 13;
            break;

            case INTCTRL_INT_C:
            priReg |= interrupts[i].groupPriority << 21;
            break;

            case INTCTRL_INT_D:
            priReg |= interrupts[i].groupPriority << 29;
            break;
        } //switch

#elif INTERRUPT_PRIORITY_LEVEL_SEL == 0x5
        switch(interruptSection)
        {
            case INTCTRL_INT_A:
            priReg |= (interrupts[i].groupPriority << 6) | (interrupts[i].subPriority << 5);
            break;

            case INTCTRL_INT_B:
            priReg |= (interrupts[i].groupPriority << 14) | (interrupts[i].subPriority << 13);
            break;

            case INTCTRL_INT_C:
            priReg |= (interrupts[i].groupPriority << 22) | (interrupts[i].subPriority << 21);
            break;

            case INTCTRL_INT_D:
            priReg |= (interrupts[i].groupPriority << 30) | (interrupts[i].subPriority << 29);
            break;
        } //switch

#elif INTERRUPT_PRIORITY_LEVEL_SEL == 0x6
        switch(interruptSection)
        {
            case INTCTRL_INT_A:
            priReg |= (interrupts[i].groupPriority << 7) | (interrupts[i].subPriority << 5);
            break;

            case INTCTRL_INT_B:
            priReg |= (interrupts[i].groupPriority << 15) | (interrupts[i].subPriority << 13);
            break;

            case INTCTRL_INT_C:
            priReg |= (interrupts[i].groupPriority << 23) | (interrupts[i].subPriority << 21);
            break;

            case INTCTRL_INT_D:
            priReg |= (interrupts[i].groupPriority << 31) | (interrupts[i].subPriority << 29);
            break;
        } //switch

#elif INTERRUPT_PRIORITY_LEVEL_SEL == 0x7
        switch(interruptSection)
        {
            case INTCTRL_INT_A:
            priReg |= interrupts[i].subPriority << 5;
            break;

            case INTCTRL_INT_B:
            priReg |= interrupts[i].subPriority << 13;
            break;

            case INTCTRL_INT_C:
            priReg |= interrupts[i].subPriority << 21;
            break;

            case INTCTRL_INT_D:
            priReg |= interrupts[i].subPriority << 29;
            break;
        } //switch
#endif
    } //for

    SYSPRI1 = (USAGE_FAULT_PRIORITY<<21) | (BUS_FAULT_PRIORITY<<13) | (MEMORY_MANAGEMENT_FAULT_PRIORITY<<5);
    SYSPRI2 = SVCALL_PRIORITY<<29;
    SYSPRI3 = (SYSTICK_EXCEPTION_PRIORITY<<29) | (PENDSV_PRIORITY<<21) | (DEBUG_PRIORITY<<5);

    /*TODO: Enable/Disable based on user configuration in NVIC_ENx and SCB_SYS Registers.*/
    for(uint8 i=0; i<NUMBER_OF_USED_INTERRUPTS; i++)
    { 
        if(interrupts[i].isEnabled == TRUE)
        {
            interruptNumber = interrupts[i].interruptNumber;
            uint8 numberOfEnReg = interruptNumber / 32;
            uint8 numberOfEnBit = interruptNumber - (numberOfEnReg * 32);

            uint32* p_wantedEnRegAddress = ((volatile uint32*)(Enable_BASE_ADDRESS)) + numberOfEnReg;
            uint32 enReg = *p_wantedEnRegAddress;

            enReg |= (1<<numberOfEnBit);

        } //if
    } //for
}

/**********************************************************************************************************************
 *  END OF FILE: IntCtrl.c
 *********************************************************************************************************************/
